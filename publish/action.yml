name: 'Publish to NPM'
description: 'Publish packages to npm using bump with Slack notifications'
author: 'SylphxAI'

branding:
  icon: 'package'
  color: 'blue'

inputs:
  # ========== Bump Configuration ==========
  mode:
    description: 'Bump mode: auto (default), release, version, or pr'
    default: 'auto'
  base-branch:
    description: 'Base branch for PR mode'
    default: 'main'

  # ========== Build Configuration ==========
  build-command:
    description: 'Command to build packages (runs before publish)'
    default: ''
  skip-build:
    description: 'Skip the build step'
    default: 'false'
  test-command:
    description: 'Command to run tests before publishing (optional)'
    default: ''

  # ========== Runtime Configuration ==========
  bun-version:
    description: 'Bun version to use'
    default: 'latest'
  node-version:
    description: 'Node.js version (for npm publish)'
    default: '20'

  # ========== Registry Configuration ==========
  npm-registry:
    description: 'NPM registry URL'
    default: 'https://registry.npmjs.org'

  # ========== Release Configuration ==========
  dry-run:
    description: 'Preview changes without publishing'
    default: 'false'
  tag:
    description: 'Create git tags'
    default: 'true'
  changelog:
    description: 'Update CHANGELOG.md'
    default: 'true'
  github-release:
    description: 'Create GitHub release'
    default: 'true'

  # ========== Multi-platform Support ==========
  download-artifacts:
    description: 'Download build artifacts before publishing'
    default: 'false'
  artifacts-path:
    description: 'Path to download artifacts to'
    default: 'artifacts'
  pre-publish-command:
    description: 'Command to run before bump (e.g., create platform packages)'
    default: ''
  post-publish-command:
    description: 'Command to run after successful publish'
    default: ''

  # ========== Notification ==========
  slack-webhook:
    description: 'Slack webhook URL for notifications'
    default: ''

  # ========== Advanced Options ==========
  working-directory:
    description: 'Working directory for commands'
    default: '.'

  # ========== Required Secrets (passed as inputs) ==========
  npm-token:
    description: 'NPM authentication token'
    required: true
  github-token:
    description: 'GitHub token for creating releases and PRs'
    required: true

outputs:
  published:
    description: 'Whether packages were published'
    value: ${{ steps.bump.outputs.published }}
  version:
    description: 'The new version (for single package repos)'
    value: ${{ steps.bump.outputs.version }}
  versions:
    description: 'JSON object of package versions (for monorepos)'
    value: ${{ steps.bump.outputs.versions }}

runs:
  using: 'composite'
  steps:
    - name: Download build artifacts
      if: inputs.download-artifacts == 'true'
      uses: actions/download-artifact@v4
      with:
        path: ${{ inputs.artifacts-path }}

    - name: Build (if configured)
      if: inputs.build-command != '' && inputs.skip-build != 'true'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: ${{ inputs.build-command }}

    - name: Run Tests
      if: inputs.test-command != ''
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: ${{ inputs.test-command }}

    - name: Pre-publish setup
      if: inputs.pre-publish-command != ''
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: ${{ inputs.pre-publish-command }}

    - name: Resolve workspace protocol
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        # Resolve workspace:^ to actual versions for npm publish compatibility
        if grep -rq '"workspace:' . --include="package.json" 2>/dev/null; then
          echo "üîß Resolving workspace:^ protocol..."

          bun -e "
            const fs = require('fs');
            const path = require('path');

            // Get all workspace package versions
            const workspaceVersions = new Map();
            const rootPkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            const workspaces = rootPkg.workspaces || [];

            for (const pattern of workspaces) {
              try {
                const baseDir = pattern.replace('/*', '');
                const dirs = fs.readdirSync(baseDir);
                for (const dir of dirs) {
                  const pkgPath = path.join(baseDir, dir, 'package.json');
                  if (fs.existsSync(pkgPath)) {
                    const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
                    if (pkg.name && pkg.version) {
                      workspaceVersions.set(pkg.name, pkg.version);
                    }
                  }
                }
              } catch (e) {}
            }

            // Resolve workspace: in all package.json files
            const resolveWorkspace = (deps) => {
              if (!deps) return false;
              let modified = false;
              for (const [name, version] of Object.entries(deps)) {
                if (typeof version === 'string' && version.startsWith('workspace:')) {
                  const actualVersion = workspaceVersions.get(name);
                  if (actualVersion) {
                    const prefix = version.replace('workspace:', '').replace('*', '^');
                    deps[name] = (prefix === '^' || prefix === '') ? '^' + actualVersion : prefix + actualVersion;
                    modified = true;
                  }
                }
              }
              return modified;
            };

            const processPackage = (pkgPath) => {
              const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
              let modified = false;
              modified = resolveWorkspace(pkg.dependencies) || modified;
              modified = resolveWorkspace(pkg.devDependencies) || modified;
              modified = resolveWorkspace(pkg.peerDependencies) || modified;
              if (modified) {
                fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2) + '\n');
                console.log('  ‚úÖ Resolved:', pkgPath);
              }
            };

            // Process root and all workspace packages
            processPackage('package.json');
            for (const pattern of workspaces) {
              try {
                const baseDir = pattern.replace('/*', '');
                const dirs = fs.readdirSync(baseDir);
                for (const dir of dirs) {
                  const pkgPath = path.join(baseDir, dir, 'package.json');
                  if (fs.existsSync(pkgPath)) {
                    processPackage(pkgPath);
                  }
                }
              } catch (e) {}
            }
          " 2>/dev/null || true

          echo "‚úÖ Workspace protocol resolution complete"
        fi

    - name: Run Bump
      id: bump
      uses: SylphxAI/bump@v0
      with:
        mode: ${{ inputs.mode }}
        base-branch: ${{ inputs.base-branch }}
        dry-run: ${{ inputs.dry-run }}
        tag: ${{ inputs.tag }}
        changelog: ${{ inputs.changelog }}
        github-release: ${{ inputs.github-release }}
        working-directory: ${{ inputs.working-directory }}
        github-token: ${{ inputs.github-token }}
        npm-token: ${{ inputs.npm-token }}

    - name: Post-publish actions
      if: inputs.post-publish-command != '' && steps.bump.outputs.published == 'true'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: ${{ inputs.post-publish-command }}

    - name: Notify Slack on publish
      if: steps.bump.outputs.published == 'true' && inputs.slack-webhook != ''
      shell: bash
      env:
        SLACK_WEBHOOK: ${{ inputs.slack-webhook }}
        VERSION: ${{ steps.bump.outputs.version }}
        VERSIONS: ${{ steps.bump.outputs.versions }}
      run: |
        REPO="${{ github.repository }}"
        REPO_URL="https://github.com/$REPO"

        # Build message based on single package or monorepo
        if [ -n "$VERSION" ]; then
          # Single package
          PKG_NAME=$(jq -r .name package.json 2>/dev/null || echo "$REPO")
          MESSAGE="üì¶ *${PKG_NAME}* \`v${VERSION}\` published\n<${REPO_URL}/releases/tag/v${VERSION}|View Release>"
        elif [ -n "$VERSIONS" ] && [ "$VERSIONS" != "{}" ]; then
          # Monorepo - list all packages
          MESSAGE="üì¶ *Packages published*\n"
          for pkg in $(echo "$VERSIONS" | jq -r 'keys[]' 2>/dev/null); do
            ver=$(echo "$VERSIONS" | jq -r --arg p "$pkg" '.[$p]' 2>/dev/null)
            MESSAGE="${MESSAGE}‚Ä¢ ${pkg}@${ver}\n"
          done
          MESSAGE="${MESSAGE}<${REPO_URL}|View Repository>"
        else
          MESSAGE="üì¶ Release published from *${REPO}*\n<${REPO_URL}|View Repository>"
        fi

        # Send to Slack
        curl -s -X POST "$SLACK_WEBHOOK" \
          -H "Content-Type: application/json" \
          -d "{\"text\": \"${MESSAGE}\"}"

    - name: Notify Slack on failure
      if: failure() && inputs.slack-webhook != ''
      shell: bash
      run: |
        WEBHOOK="${{ inputs.slack-webhook }}"
        REPO="${{ github.repository }}"
        RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
        BRANCH="${{ github.ref_name }}"

        MESSAGE="‚ùå *Publish failed*\n"
        MESSAGE="${MESSAGE}Repository: ${REPO}\n"
        MESSAGE="${MESSAGE}Branch: ${BRANCH}\n"
        MESSAGE="${MESSAGE}<${RUN_URL}|View Workflow>"

        curl -s -X POST "$WEBHOOK" \
          -H "Content-Type: application/json" \
          -d "{\"text\": \"${MESSAGE}\"}"
